package com.coinblesk.server.service;

import com.coinblesk.server.config.AppConfig;
import com.coinblesk.server.dao.AccountRepository;
import com.coinblesk.server.entity.Account;
import com.coinblesk.server.exceptions.InvalidAmountException;
import com.coinblesk.server.exceptions.InvalidNonceException;
import com.coinblesk.server.exceptions.InvalidRequestException;
import com.coinblesk.server.exceptions.UserNotFoundException;
import com.coinblesk.server.utils.DTOUtils;
import com.coinblesk.util.InsufficientFunds;
import lombok.Data;
import lombok.NonNull;
import org.bitcoinj.core.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.TransientDataAccessException;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

@Service
public class MicropaymentService {
	private final AccountRepository accountRepository;

	@Autowired
	AppConfig appConfig;

	@Autowired WalletService walletService;

	@Autowired AccountService accountService;

	@Autowired
	public MicropaymentService(AccountRepository accountRepository) {
		this.accountRepository = accountRepository;
	}

	@Transactional(isolation = Isolation.SERIALIZABLE)
	@Retryable(TransientDataAccessException.class)
	public VirtualPaymentResult virtualPayment(@NonNull ECKey keySender, @NonNull ECKey keyReceiver, long amount, long requestNonce)
			throws InvalidNonceException, UserNotFoundException, InvalidAmountException, InsufficientFunds, InvalidRequestException {

		// Sender and receiver must be different entities
		if (keySender.getPublicKeyAsHex().equals(keyReceiver.getPublicKeyAsHex()))
			throw new InvalidRequestException("The sender and receiver cannot be the same entities");

		final Account sender = accountRepository.findByClientPublicKey(keySender.getPubKey());
		if (sender == null)
			throw new UserNotFoundException(keySender.getPublicKeyAsHex());

		// Abort if the nonce is not fresh, we allow only higher nonces than in the database
		// The nonce is generated by the client as unix epoch time in milliseconds.
		// This prevents possible replay attacks:
		// If we receive the same nonce as in the database, the request was probably sent two times
		// If the nonce in the database is larger than the request, we probably got an old request sent again.
		if (requestNonce <= sender.nonce())
			throw new InvalidNonceException("Invalid nonce. Request already processed?");

		// Fail if amount is invalid
		if (amount < 1)
			throw new InvalidAmountException("Invalid amount. Must be 1 or larger.");

		// Check for sufficient funds
		if (amount > sender.virtualBalance())
			throw new InsufficientFunds("Insufficient funds, only " + sender.virtualBalance() + " satoshis available");

		// Get receiver from database
		final Account receiver = accountRepository.findByClientPublicKey(keyReceiver.getPubKey());
		if (receiver == null)
			throw new UserNotFoundException(keyReceiver.getPublicKeyAsHex());

		// Do the transfer
		final long senderOldBalance = sender.virtualBalance();
		final long receiverOldBalance = receiver.virtualBalance();
		sender.virtualBalance(senderOldBalance - amount);
		receiver.virtualBalance(receiverOldBalance + amount);

		// Guarantee that this request is only processed once
		sender.nonce(requestNonce);

		accountRepository.save(sender);
		accountRepository.save(receiver);

		// Return the new balances and the keys for sender and receiver that can be used for signing
		return new VirtualPaymentResult(
				sender.virtualBalance(),
				sender.serverPrivateKey(),
				receiver.virtualBalance(),
				receiver.serverPrivateKey()
		);
	}

	@Transactional(isolation = Isolation.SERIALIZABLE)
	public void microPayment(ECKey senderPublicKey, ECKey receiverPublicKey, String txInHex, Long amount) {

		// Parse the transaction
		byte[] txInByes = DTOUtils.fromHex(txInHex);
		final Transaction tx;
		tx = new Transaction(appConfig.getNetworkParameters(), txInByes);
		tx.verify(); // Checks for no input or outputs and no negative values.

		// Make sure all the UTXOs are known to the wallet
		List<TransactionOutput> spentOutputs = tx.getInputs().stream().map(walletService::findOutputFor).collect(Collectors.toList());
		if (spentOutputs.stream().anyMatch(Objects::isNull)) {
			throw new RuntimeException("Transaction spends unknown UTXOs");
		}

		// Gather all addresses from the input and make sure they are in the P2SH format
		List<Address> spentAddresses = spentOutputs.stream()
			.map(transactionOutput -> transactionOutput.getAddressFromP2SH(appConfig.getNetworkParameters()))
			.collect(Collectors.toList());
		if (spentAddresses.stream().anyMatch(Objects::isNull)) {
			throw new RuntimeException("Transaction must spent P2SH addresses");
		}

		// Gather all accounts belonging to the addresses from the inputs
		List<byte[]> addressHashes = spentAddresses.stream()
			.map(Address::getHash160)
			.collect(Collectors.toList());

		// Make sure the addresses belong all to the same single account
		List<Account> spendingAccounts = accountService.getAccountByAddressHashes(addressHashes);
		if (spendingAccounts.isEmpty()) {
			throw new RuntimeException("Used TLA inputs are not known to server");
		}
		if (spendingAccounts.size() != 1) {
			throw new RuntimeException("Inputs must be from one account");
		}

		Account accountSender = spendingAccounts.get(0);

		if (!ECKey.fromPublicOnly(accountSender.clientPublicKey()).equals(senderPublicKey)) {
			throw new RuntimeException("Request was not signed by owner of inputs");
		}

		// Make sure the receiving public key is known to the server
		final Account accountReceiver = accountService.getByClientPublicKey(receiverPublicKey.getPubKey());
		if (accountReceiver == null) {
			throw new RuntimeException("Receiver is unknown to server");
		}

	}

	/**
	 * Result of a successful virtual payment.
	 * Contains the new balances and both private keys of the server.
	 * These can be used to sign the resulting information.
	 */
	public @Data class VirtualPaymentResult {
		private final long newBalanceSender;
		private final byte[] serverPrivateKeyForSender;

		private final long newBalanceReceiver;
		private final byte[] serverPrivateKeyForReceiver;
	}
}
